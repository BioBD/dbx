wordsBySGBD=vacuum;analyze;pg_type;pg_namespace;tb_candidate_view;db.dattablespace;tb_workload;pg_catalog;pg_attribute;pg_roles;qp.query_plan;news;captured;pg_stat_activity;create procedure;explain;update;statman;schema_name;collation_name;plan_table;tb_workload
getSqlClauseToUpdateQueryTbWorkload= update tb_workload set wld_capture_count = wld_capture_count + 1, wld_plan = ? where wld_id =?
getSqlClauseToInsertQueryTbWorkload= insert into tb_workload ( wld_sql, wld_plan, wld_capture_count, wld_analyze_count, wld_relevance, wld_type ) values (?,?,?,?,?,?)
getSqlClauseToCheckIfQueryIsAlreadyCaptured= select wld_id from tb_workload where wld_sql like ?
getSqlQueriesNotAnalizedObserver= select * from tb_workload left join tb_candidate_view on (wld_id = cmv_id) where wld_capture_count > wld_analyze_count order by wld_capture_count desc
getSqlClauseToInsertDDLCreateMV= INSERT INTO tb_candidate_view (cmv_id, cmv_ddl_create, cmv_cost, cmv_profit, cmv_status) VALUES (?, ?, ?, ?, ?); update tb_workload set wld_analyze_count = wld_capture_count where wld_id = ?
getSqlClauseToUpdateWldAnalyzeCount= update tb_workload set wld_analyze_count = wld_capture_count
getSqlClauseToIncrementBenefictDDLCreateMV= update tb_candidate_view set cmv_cost = ?, cmv_profit = ? where cmv_id = ?
getSqlDDLNotAnalizedPredictor=select cmv_id, cmv_cost, cmv_profit from tb_candidate_view where cmv_profit > 0 and cmv_profit > cmv_cost and cmv_status = 'H'
getSqlClauseToUpdateDDLCreateMVToMaterialization=update tb_candidate_view set cmv_status = ? where cmv_id = ?
getSqlClauseToUpdateTemporaryDDLCreateMVToMaterialization=update tb_candidate_view set cmv_status = 'H' where cmv_status = 'M'
getSqlClauseToGetDiskSpaceOccupied=select sum(cmv_cost) from tb_candidate_view where cmv_status = 'R'
getSqlDDLNotAnalizedReactor=select * from tb_workload inner join tb_candidate_view on (wld_id = cmv_id) where cmv_status = 'M'
# getSqlClauseToCaptureCurrentQueries from multiples databases
getSqlClauseToCaptureCurrentQueriespostgresql=select pid, query as sql, query_start as start_time, datname as database_name from pg_stat_activity where datname like ?;
getSqlClauseToCaptureCurrentQueriessqlserver=SELECT session_id as pid, text as sql, start_time as start_time FROM sys.dm_exec_requests req CROSS APPLY sys.dm_exec_sql_text(sql_handle) AS sqltext WHERE DB_NAME(database_id) like ?;
getSqlClauseToCaptureCurrentQueriesoracle=SELECT s.sql_id pid, s.sql_fulltext sql, s.last_load_time start_time, u.username database_name FROM SYS.V_$SQL S, SYS.ALL_USERS U, V$SESSION SN WHERE S.PARSING_USER_ID = U.USER_ID AND SN.sql_hash_value = S.hash_value AND SN.sql_address = S.address and u.username like ? ORDER BY S.LAST_LOAD_TIME
# getSqlTableNames from multiples databases
getSqlTableNamespostgresql=SELECT  nspname as schema, relname as tablename, reltuples as numberrows, relpages as numberpages FROM pg_class C LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace) WHERE  nspname NOT IN ('pg_catalog', 'information_schema') AND relkind='r'  ORDER BY reltuples DESC;
getSqlTableNamesoracle=select 'TPCH' schema,  table_name,  to_number(extractvalue(xmltype(dbms_xmlgen.getxml('select count(*) c from '||table_name)),'/ROWSET/ROW/C')) numberrows,  CASE WHEN bytes is null THEN 0 else bytes end numberpages   FROM user_tables   left join user_segments on segment_name = table_name
getSqlTableNamessqlserver= SELECT t.name AS table_name, (SELECT STUFF(( SELECT ', ' + c.name FROM sys.columns c where t.OBJECT_ID = c.OBJECT_ID FOR XML PATH('') ), 1,1,'') AS activities ) AS f, s.name AS schemas_name FROM sys.tables AS t INNER JOIN sys.columns c ON t.OBJECT_ID = c.OBJECT_ID INNER JOIN sys.schemas s ON t.schema_id = s.schema_id group by t.name, t.OBJECT_ID, s.name
# getSqlTableLength from multiples databases
getSqlTableLengthpostgresql=SELECT reltuples FROM pg_class WHERE relname= ?;
# getResultPlanQuerySQLServer from multiples databases
getResultPlanQuerySQLServer=SELECT qp.query_plan AS QueryPlan FROM sys.dm_exec_cached_plans AS cp CROSS APPLY sys.dm_exec_query_plan(cp.plan_handle) AS qp CROSS APPLY sys.dm_exec_sql_text(cp.plan_handle) AS st where cp.objtype = 'Adhoc' and st.TEXT like ?;
# getSqlDetailsColumnspostgresql from multiples databases
getSqlDetailsColumnspostgresql=SELECT f.attnum AS number, f.attname AS name, f.attnotnull AS notnull, pg_catalog.format_type(f.atttypid,f.atttypmod) AS type, CASE WHEN f.atthasdef = 't' THEN d.adsrc END AS default, coalesce(p.contype = 'p', false) AS primarykey, coalesce(p.contype = 'u', false) AS uniquekey, coalesce(p.contype = 'f', false) AS foreignkey, CASE WHEN p.contype = 'f' THEN fk.attnum END AS foreignkey_fieldnum, CASE WHEN p.contype = 'f' THEN fk.attname END AS foreignkey_name, CASE WHEN p.contype = 'f' THEN g.relname END AS foreignkey_table, CASE WHEN p.contype = 'f' THEN pg_catalog.format_type(f.atttypid,f.atttypmod) END AS foreignkey_type FROM pg_attribute f JOIN pg_class c ON c.oid = f.attrelid JOIN pg_type t ON t.oid = f.atttypid LEFT JOIN pg_attrdef d ON d.adrelid = c.oid AND d.adnum = f.attnum LEFT JOIN pg_namespace n ON n.oid = c.relnamespace LEFT JOIN pg_constraint p ON p.conrelid = c.oid AND f.attnum = ANY (p.conkey) LEFT JOIN pg_class AS g ON p.confrelid = g.oid LEFT JOIN pg_attribute as fk ON g.oid = fk.attrelid AND fk.attnum = ANY (p.confkey) WHERE c.relkind = 'r' AND f.attrelid = '$schema$.$table$'::regclass AND f.attnum > 0 ORDER BY number ;
getSqlDetailsColumnsoracle=SELECT    user_tab_cols.COLUMN_ID,   user_tab_cols.column_name,   user_tab_cols.nullable,   user_tab_cols.data_type,   null domainrestriction,   case when pk.primarykey = 'P' then 't' else 'f' end primarykey,   case when uk.uniquekey = 'P' then 't' else 'f' end uniquekey,   case when fk.foreignkey = 'P' then 't' else 'f' end foreignkey FROM user_tab_cols  left join (SELECT   cols.table_name,   cols.column_name,    cons.constraint_type primarykey FROM    all_constraints cons,    all_cons_columns cols WHERE cons.constraint_name = cols.constraint_name AND cons.owner = cols.owner AND cons.constraint_type = 'P') pk on (pk.table_name = user_tab_cols.table_name and user_tab_cols.column_name = pk.column_name)   left join (SELECT   cols.table_name,   cols.column_name,    cons.constraint_type uniquekey FROM    all_constraints cons,    all_cons_columns cols WHERE cons.constraint_name = cols.constraint_name AND cons.owner = cols.owner AND (cons.constraint_type = 'U' or cons.constraint_type = 'P')) uk on (uk.table_name = user_tab_cols.table_name and user_tab_cols.column_name = uk.column_name)  left join (SELECT   cols.table_name,   cols.column_name,    cons.constraint_type foreignkey FROM    all_constraints cons,    all_cons_columns cols WHERE cons.constraint_name = cols.constraint_name AND cons.owner = cols.owner AND cons.constraint_type = 'R') fk on (fk.table_name = user_tab_cols.table_name and user_tab_cols.column_name = fk.column_name) WHERE user_tab_cols.table_name = '$table$'
# getDDLCreateMV from multiples databases
getDDLCreateMVpostgresql=drop materialized view if exists $nameMV$; create materialized view $nameMV$ as $sqlMV$;
getDDLCreateMVoracle=CREATE MATERIALIZED VIEW $nameMV$ CACHE REFRESH ON COMMIT COMPLETE ENABLE QUERY REWRITE AS $sqlMV$
