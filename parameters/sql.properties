wordsBySGBD=vacuum;analyze;pg_type;pg_namespace;tb_candidate_view;db.dattablespace;tb_workload;pg_catalog;pg_attribute;pg_roles;qp.query_plan;news;captured;pg_stat_activity;create procedure;explain;update;statman;schema_name;collation_name
getSqlClauseToUpdateQueryTbWorkload= update agent.tb_workload set wld_capture_count = wld_capture_count + 1, wld_plan = ? where wld_id =?
getSqlClauseToInsertQueryTbWorkload= insert into agent.tb_workload ( wld_sql, wld_plan, wld_capture_count, wld_analyze_count, wld_type ) values (?,?,?,?,?)
getSqlClauseToCheckIfQueryIsAlreadyCaptured= select wld_id from agent.tb_workload where wld_sql like ?
getSqlQueriesNotAnalized= select * from agent.tb_workload where wld_capture_count > wld_analyze_count order by wld_capture_count desc
getSqlClauseToInsertDDLCreateMV= INSERT INTO agent.tb_candidate_view (cmv_id, cmv_ddl_create, cmv_cost, cmv_profit, cmv_status) VALUES (?, ?, ?, ?, ?); update agent.tb_workload set wld_analyze_count = wld_capture_count where wld_id = ?;
getSqlClauseToUpdateWldAnalyzeCount= update agent.tb_workload set wld_analyze_count = wld_capture_count;
getSqlClauseToIncrementBenefictDDLCreateMV= update agent.tb_candidate_view set cmv_cost = ?, cmv_profit = ? where cmv_id = ?;
getSqlDDLNotAnalizedPredictor= select cmv_id, cmv_cost, cmv_profit from agent.tb_candidate_view where cmv_profit > 0 and cmv_profit > cmv_cost and cmv_status = 'H';
getSqlClauseToUpdateDDLCreateMVToMaterialization=update agent.tb_candidate_view set cmv_status = ? where cmv_id = ?;
getSqlClauseToGetDiskSpaceOccupied=select sum(cmv_cost) from agent.tb_candidate_view where cmv_status <> 'H';
getSqlDDLNotAnalizedReactor=select * from agent.tb_workload inner join agent.tb_candidate_view on (wld_id = cmv_id) where cmv_status = 'M'
# getSqlClauseToCaptureCurrentQueries from multiples databases
getSqlClauseToCaptureCurrentQueriespostgresql=select pid, query as sql, query_start as start_time, datname as database_name from pg_stat_activity where datname like ?;
getSqlClauseToCaptureCurrentQueriessqlserver=SELECT session_id as pid, text as sql, start_time as start_time FROM sys.dm_exec_requests req CROSS APPLY sys.dm_exec_sql_text(sql_handle) AS sqltext WHERE DB_NAME(database_id) like ?;
# getSqlTableNames from multiples databases
getSqlTableNamespostgresql=SELECT  nspname as schema, relname as tablename, reltuples as numberrows, relpages as numberpages FROM pg_class C LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace) WHERE  nspname NOT IN ('pg_catalog', 'information_schema') AND relkind='r'  ORDER BY reltuples DESC;
getSqlTableNamessqlserver= SELECT t.name AS table_name, (SELECT STUFF(( SELECT ', ' + c.name FROM sys.columns c where t.OBJECT_ID = c.OBJECT_ID FOR XML PATH('') ), 1,1,'') AS activities ) AS f, s.name AS schemas_name FROM sys.tables AS t INNER JOIN sys.columns c ON t.OBJECT_ID = c.OBJECT_ID INNER JOIN sys.schemas s ON t.schema_id = s.schema_id group by t.name, t.OBJECT_ID, s.name
# getSqlTableLength from multiples databases
getSqlTableLengthpostgresql=SELECT reltuples FROM pg_class WHERE relname= ?;
# getResultPlanQuerySQLServer from multiples databases
getResultPlanQuerySQLServer=SELECT qp.query_plan AS QueryPlan FROM sys.dm_exec_cached_plans AS cp CROSS APPLY sys.dm_exec_query_plan(cp.plan_handle) AS qp CROSS APPLY sys.dm_exec_sql_text(cp.plan_handle) AS st where cp.objtype = 'Adhoc' and st.TEXT like ?;
# getSqlDetailsColumnspostgresql from multiples databases
getSqlDetailsColumnspostgresql=SELECT f.attnum AS number, f.attname AS name, f.attnotnull AS notnull, pg_catalog.format_type(f.atttypid,f.atttypmod) AS type, CASE WHEN f.atthasdef = 't' THEN d.adsrc END AS default, coalesce(p.contype = 'p', false) AS primarykey, coalesce(p.contype = 'u', false) AS uniquekey, coalesce(p.contype = 'f', false) AS foreignkey, CASE WHEN p.contype = 'f' THEN fk.attnum END AS foreignkey_fieldnum, CASE WHEN p.contype = 'f' THEN fk.attname END AS foreignkey_name, CASE WHEN p.contype = 'f' THEN g.relname END AS foreignkey_table, CASE WHEN p.contype = 'f' THEN pg_catalog.format_type(f.atttypid,f.atttypmod) END AS foreignkey_type FROM pg_attribute f JOIN pg_class c ON c.oid = f.attrelid JOIN pg_type t ON t.oid = f.atttypid LEFT JOIN pg_attrdef d ON d.adrelid = c.oid AND d.adnum = f.attnum LEFT JOIN pg_namespace n ON n.oid = c.relnamespace LEFT JOIN pg_constraint p ON p.conrelid = c.oid AND f.attnum = ANY (p.conkey) LEFT JOIN pg_class AS g ON p.confrelid = g.oid LEFT JOIN pg_attribute as fk ON g.oid = fk.attrelid AND fk.attnum = ANY (p.confkey) WHERE c.relkind = 'r' AND f.attrelid = '?'::regclass AND f.attnum > 0 ORDER BY number ; 


